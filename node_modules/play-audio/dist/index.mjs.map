{"version":3,"sources":["../play-audio/opus/DuplexStream.ts","../play-audio/opus/modules/play-opus.ts","../play-audio/opus/modules/opusscript.ts","../play-audio/opus/modules/loader.ts","../play-audio/opus/OpusEncoder.ts","../play-audio/opus/OpusDecoder.ts","../play-audio/ogg/OggDemuxer.ts","../play-audio/webm/WebmDemuxer.ts","../play-audio/webm/WebmConstant.ts","../play-audio/webm/WebmHeader.ts","../play-audio/ffmpeg/index.ts","../play-audio/index.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'stream';\nimport { OpusHandlerOptions } from './modules/constant';\nimport { createOpusHandler, OpusEncoder } from './modules/loader';\n\nexport enum OpusCTL {\n    SetBitrate = 4002,\n    SetFEC = 4012,\n    SetPLP = 4014\n}\n\nexport interface OpusTransformOptions extends OpusHandlerOptions {\n    encoder?: 'play-opus' | 'opusscript';\n    duplex?: DuplexOptions;\n}\n\nexport abstract class OpusDuplexStream extends Duplex {\n    protected pcm_length: number;\n    protected encoder: OpusEncoder;\n\n    constructor(options: OpusTransformOptions) {\n        super(options.duplex);\n        const handler = createOpusHandler(options, options.encoder);\n        if (handler instanceof Error) throw handler;\n        this.encoder = handler;\n        this.pcm_length = options.frameSize * options.channels * 2;\n    }\n\n    protected encode(buf: Buffer) {\n        return this.encoder.encode(buf);\n    }\n\n    protected decode(buffer: Buffer) {\n        return this.encoder.decode(buffer);\n    }\n\n    private cleanup() {\n        this.encoder.delete();\n    }\n\n    _read() {}\n\n    _destroy(error: Error | null, callback: (error: Error | null) => void): void {\n        this.cleanup();\n        callback(error);\n    }\n\n    public abstract _write(chunk: Buffer, enc: BufferEncoding, next: (error?: Error | null) => void): void;\n\n    _final(callback: (error?: Error | null) => void): void {\n        this.cleanup();\n        this.push(null);\n        callback();\n    }\n\n    public abstract applyCTL(ctl: number, value: number): void;\n\n    public bitrate(bitrate: number) {\n        return this.applyCTL(OpusCTL.SetBitrate, bitrate);\n    }\n\n    public setFEC(enabled: boolean) {\n        return this.applyCTL(OpusCTL.SetFEC, enabled ? 1 : 0);\n    }\n\n    public setPLP(percentage: number) {\n        return this.applyCTL(OpusCTL.SetPLP, Math.min(100, Math.max(0, percentage * 100)));\n    }\n}\n","import { OpusHandlerOptions } from './constant';\n\nexport class OpusHandler {\n    protected options: OpusHandlerOptions;\n    private encoder: any;\n    constructor(options: OpusHandlerOptions) {\n        const pack = require('play-opus');\n        this.options = options;\n        this.encoder = new pack.OpusHandler(options.rate, options.channels);\n    }\n\n    encode(buf: Buffer): Buffer {\n        return this.encoder.encode(buf);\n    }\n\n    decode(buf: Buffer): Buffer {\n        return this.encoder.decode(buf);\n    }\n\n    encode_ctl(ctl: number, val: number) {\n        this.encode_ctl(ctl, val);\n    }\n\n    decode_ctl(ctl: number, val: number) {\n        this.decode_ctl(ctl, val);\n    }\n\n    delete() {\n        this.encoder.delete();\n    }\n}\n","import { OpusHandlerOptions } from './constant';\n\nexport class OpusHandler {\n    protected options: OpusHandlerOptions;\n    private encoder: any;\n    constructor(options: OpusHandlerOptions) {\n        const OpusScript = require('opusscript');\n        this.options = options;\n        this.encoder = new OpusScript(options.rate, options.channels);\n    }\n\n    encode(buf: Buffer): Buffer {\n        return this.encoder.encode(buf, this.options.frameSize);\n    }\n\n    decode(buf: Buffer): Buffer {\n        return this.encoder.decode(buf);\n    }\n\n    encode_ctl(ctl: number, val: number) {\n        this.encode_ctl(ctl, val);\n    }\n\n    decode_ctl(ctl: number, val: number) {\n        this.decode_ctl(ctl, val);\n    }\n\n    delete() {\n        this.encoder.delete();\n    }\n}\n","import { OpusHandlerOptions } from './constant';\nimport { OpusHandler as PlayHandler } from './play-opus';\nimport { OpusHandler as ScriptHandler } from './opusscript';\n\nexport type OpusEncoder = PlayHandler | ScriptHandler;\n\nconst modules = {\n    'play-opus': (options: OpusHandlerOptions) => new PlayHandler(options),\n    'opusscript': (options: OpusHandlerOptions) => new ScriptHandler(options)\n};\n\nexport function createOpusHandler(\n    options: OpusHandlerOptions,\n    preference?: 'play-opus' | 'opusscript'\n): OpusEncoder | Error {\n    if (preference) {\n        if (preference !== 'opusscript' && preference !== 'play-opus')\n            return new Error('Supported modules for play-media :\\n- play-opus\\n- opusscript');\n        try {\n            require(preference);\n        } catch {\n            return new Error(`Module [${preference}] Not Found.`);\n        }\n        return modules[preference](options);\n    } else {\n        for (const [name, exec] of Object.entries(modules)) {\n            try {\n                require(name);\n                return exec(options);\n            } catch {\n                continue;\n            }\n        }\n        return new Error('No modules found. Try to install one of following :\\n- play-opus\\n- opusscript');\n    }\n}\n","import { OpusDuplexStream, OpusTransformOptions } from './DuplexStream';\n\nexport class OpusEncoder extends OpusDuplexStream {\n    private remaining: Buffer;\n\n    constructor(options: OpusTransformOptions) {\n        super(options);\n        this.remaining = Buffer.allocUnsafe(0);\n    }\n\n    public _write(chunk: Buffer, _: BufferEncoding, done: (error?: Error | null) => void): void {\n        const pcmChunk = Buffer.concat([this.remaining, chunk]);\n\n        let i = 0;\n        while (pcmChunk.length >= i + this.pcm_length) {\n            const pcm = pcmChunk.slice(i, i + this.pcm_length);\n\n            let opus: Buffer;\n\n            try {\n                opus = this.encode(pcm);\n            } catch (err: any) {\n                done(err);\n                return;\n            }\n            this.push(opus);\n            i += this.pcm_length;\n        }\n\n        if (i > 0) this.remaining = pcmChunk.slice(i);\n        done();\n    }\n\n    applyCTL(ctl: number, value: number) {\n        this.encoder.encode_ctl(ctl, value);\n    }\n}\n","import { OpusDuplexStream, OpusTransformOptions } from './DuplexStream';\n\nconst OPUS_HEAD = Buffer.from('OpusHead');\nconst OPUS_TAGS = Buffer.from('OpusTags');\n\nexport class OpusDecoder extends OpusDuplexStream {\n    opusHead?: Buffer;\n    opusTags?: Buffer;\n\n    constructor(options: OpusTransformOptions) {\n        super(options);\n    }\n\n    public _write(chunk: Buffer, _: BufferEncoding, done: (error?: Error | null) => void): void {\n        if (chunk.compare(OPUS_HEAD, 0, 8, 0, 8) === 0) {\n            this.opusHead = chunk;\n            this.emit('opusHead', chunk);\n        } else if (chunk.compare(OPUS_TAGS, 0, 8, 0, 8) === 0) {\n            this.opusTags = chunk;\n            this.emit('opusTags', chunk);\n        } else {\n            let frame: Buffer;\n            try {\n                frame = this.encoder.decode(chunk);\n            } catch (err: any) {\n                done(err);\n                return;\n            }\n            this.push(frame);\n        }\n        done();\n    }\n\n    applyCTL(ctl: number, value: number) {\n        this.encoder.decode_ctl(ctl, value);\n    }\n}\n","import { Duplex, DuplexOptions } from 'stream';\n\nconst OGG_PAGE_HEADER_SIZE = 26;\nconst OGG_VERSION = 0;\n\nconst OGGS_HEADER = Buffer.from('OggS');\nconst OPUS_HEAD = Buffer.from('OpusHead');\nconst OPUS_TAGS = Buffer.from('OpusTags');\n\ninterface OggHeader {\n    pageSegments: number;\n    sizes: number[];\n    totalSize: number;\n}\n\ntype ParseResult = Error | Buffer | false;\n\nexport class OggDemuxer extends Duplex {\n    private remaining?: Buffer;\n    private opus_head?: Buffer;\n    private ogg_head?: OggHeader;\n\n    constructor(options?: DuplexOptions) {\n        super(options);\n    }\n\n    public _read() {}\n\n    public _write(chunk: Buffer, _: BufferEncoding, done: (error?: Error) => void) {\n        if (this.remaining) {\n            chunk = Buffer.concat([this.remaining, chunk]);\n            this.remaining = undefined;\n        }\n\n        while (true) {\n            const result = this.readOggPage(chunk);\n            if (result) {\n                if (result instanceof Error) done(result);\n                else chunk = result;\n            } else break;\n        }\n\n        this.remaining = chunk;\n        this.ogg_head = undefined;\n        done();\n    }\n\n    private readOggPage(chunk: Buffer): ParseResult {\n        if (!this.ogg_head) {\n            const result_head = this.readOggHead(chunk);\n            if (!result_head) return false;\n            if (result_head instanceof Error) return result_head;\n            return this.readOggData(result_head);\n        } else return this.readOggData(chunk);\n    }\n\n    private readOggData(chunk: Buffer): ParseResult {\n        if (!this.ogg_head) return false;\n        if (chunk.length < this.ogg_head.totalSize) return false;\n\n        let start = 0;\n        for (const size of this.ogg_head.sizes) {\n            const segment = chunk.slice(start, start + size);\n            if (this.opus_head) {\n                if (size >= 8 && segment.compare(OPUS_TAGS, 0, 8, 0, 8) === 0) this.emit('tags', segment);\n                else this.push(segment);\n            } else if (segment.compare(OPUS_HEAD, 0, 8, 0, 8) === 0) {\n                this.emit('head', segment);\n                this.opus_head = segment;\n            } else return new Error('Unknown Segment Found');\n            start += size;\n        }\n        this.ogg_head = undefined;\n        return chunk.slice(start);\n    }\n\n    private readOggHead(chunk: Buffer): ParseResult {\n        if (chunk.length < OGG_PAGE_HEADER_SIZE) return false;\n        if (chunk.compare(OGGS_HEADER, 0, 4, 0, 4) !== 0) return new Error('Capture Pattern is not OggS');\n        if (chunk.readUInt8(4) !== OGG_VERSION) return new Error(`OGG version is not equal to 0.`);\n\n        if (chunk.length < 27) return false;\n        const pageSegments = chunk.readUInt8(26);\n        if (chunk.length < 27 + pageSegments) return false;\n        const table = chunk.slice(27, 27 + pageSegments);\n\n        const sizes: number[] = [];\n        let totalSize = 0;\n\n        for (let i = 0; i < pageSegments; ) {\n            let size = 0;\n            let x = 255;\n            while (x === 255) {\n                if (i >= table.length) return false;\n                x = table.readUInt8(i);\n                i++;\n                size += x;\n            }\n            sizes.push(size);\n            totalSize += size;\n        }\n        this.ogg_head = {\n            sizes: sizes,\n            totalSize: totalSize,\n            pageSegments: pageSegments\n        };\n        return chunk.slice(27 + pageSegments);\n    }\n\n    public _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n        this._cleanup();\n        callback(err);\n    }\n\n    public _final(callback: (error?: Error) => void): void {\n        this._cleanup();\n        this.push(null);\n        callback();\n    }\n\n    public _cleanup() {\n        this.remaining = undefined;\n        this.opus_head = undefined;\n        this.ogg_head = undefined;\n    }\n}\n","import { Duplex, DuplexOptions } from 'stream';\nimport { DataType, WebmElements } from './WebmConstant';\nimport { WebmHeader } from './WebmHeader';\n\nexport class WebmDemuxer extends Duplex {\n    remaining?: Buffer;\n    chunk?: Buffer;\n    cursor: number;\n    header: WebmHeader;\n    headfound: boolean;\n    private data_size: number;\n    private data_length: number;\n\n    constructor(options?: DuplexOptions) {\n        super(options);\n        this.cursor = 0;\n        this.header = new WebmHeader();\n        this.headfound = false;\n        this.data_length = 0;\n        this.data_size = 0;\n    }\n\n    private get vint_length(): number {\n        let i = 0;\n        for (; i < 8; i++) {\n            if ((1 << (7 - i)) & this.chunk![this.cursor]) break;\n        }\n        return ++i;\n    }\n\n    private get vint_value(): boolean {\n        if (!this.chunk) return false;\n        const length = this.vint_length;\n        if (this.chunk.length < this.cursor + length) return false;\n        let value = this.chunk[this.cursor] & ((1 << (8 - length)) - 1);\n        for (let i = this.cursor + 1; i < this.cursor + length; i++) value = (value << 8) + this.chunk[i];\n        this.data_size = length;\n        this.data_length = value;\n        return true;\n    }\n\n    cleanup() {\n        this.cursor = 0;\n        this.chunk = undefined;\n        this.remaining = undefined;\n    }\n\n    _read() {}\n\n    _write(chunk: Buffer, _: BufferEncoding, done: (error?: Error | null) => void): void {\n        if (this.remaining) {\n            this.chunk = Buffer.concat([this.remaining, chunk]);\n            this.remaining = undefined;\n        } else this.chunk = chunk;\n        const tag = this.readTag();\n\n        if (tag instanceof Error) done(tag);\n        else done();\n    }\n\n    private readTag() {\n        if (!this.chunk) return new Error('Chunk is missing');\n\n        while (this.chunk.length > this.cursor) {\n            const oldCursor = this.cursor;\n            const id = this.vint_length;\n            if (this.chunk.length < this.cursor + id) break;\n\n            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));\n            this.cursor += id;\n            const vint = this.vint_value;\n\n            if (!vint) {\n                this.cursor = oldCursor;\n                break;\n            }\n            if (!ebmlID) {\n                this.cursor += this.data_size + this.data_length;\n                continue;\n            }\n\n            if (!this.headfound) {\n                if (ebmlID.name === 'ebml') this.headfound = true;\n                else return new Error('Failed to find EBML ID at start of stream.');\n            }\n\n            const data = this.chunk.slice(\n                this.cursor + this.data_size,\n                this.cursor + this.data_size + this.data_length\n            );\n            const parse = this.header.parse(ebmlID, data);\n            if (parse instanceof Error) return parse;\n\n            if (ebmlID.type === DataType.master) {\n                this.cursor += this.data_size;\n                continue;\n            }\n\n            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {\n                this.cursor = oldCursor;\n                break;\n            } else this.cursor += this.data_size + this.data_length;\n\n            if (ebmlID.name === 'simpleBlock') {\n                const track = this.header.segment.tracks![this.header.audioTrack];\n                if (!track || track.trackType !== 2) return new Error('No audio Track in this webm file.');\n                if ((data[0] & 0xf) === track.trackNumber) this.push(data.slice(4));\n            }\n        }\n        this.remaining = this.chunk.slice(this.cursor);\n        this.cursor = 0;\n    }\n\n    private parseEbmlID(ebmlID: string) {\n        if (Object.keys(WebmElements).includes(ebmlID)) return WebmElements[ebmlID];\n        else return false;\n    }\n\n    _destroy(error: Error | null, callback: (error: Error | null) => void): void {\n        this.cleanup();\n        callback(error);\n    }\n\n    _final(callback: (error?: Error | null) => void): void {\n        this.cleanup();\n        this.push(null);\n        callback();\n    }\n}\n","export enum DataType {\n    master,\n    string,\n    uint,\n    binary,\n    float\n}\n\nexport const DataReturn = {\n    string: (buf: Buffer) => buf.toString('utf-8'),\n    uint: (buf: Buffer) => parseInt(buf.toString('hex'), 16),\n    float: (buf: Buffer) => parseFloat(buf.toString('utf-8'))\n};\n\nexport type DataReturnType = (buf: Buffer) => string | number;\n\nexport interface EBML {\n    version?: number;\n    readVersion?: number;\n    maxIDLength?: number;\n    maxSizeWidth?: number;\n    docType?: string;\n    docTypeVersion?: number;\n    docTypeReadVersion?: number;\n}\n\nexport interface Seek {\n    position?: number;\n}\n\nexport type SeekHead = Seek[];\n\nexport interface Info {\n    duration?: number;\n    muxingApp?: string;\n    writingApp?: string;\n}\n\nexport type Tracks = TracksEntry[];\n\nexport interface TracksEntry {\n    trackNumber?: number;\n    trackType?: number;\n    codecID?: string;\n    audio?: Audio;\n}\n\nexport interface Audio {\n    rate?: number;\n    channels?: number;\n    bitDepth?: number;\n}\n\nexport interface CuePoint {\n    time?: number;\n    track?: number;\n    position?: number;\n}\n\nexport type Cues = CuePoint[];\n\nexport interface Cluster {\n    time?: number;\n}\n\nexport interface Segment {\n    seekHead?: SeekHead;\n    info?: Info;\n    tracks?: Tracks;\n    cues?: Cues;\n    cluster?: Cluster;\n}\n\nexport interface ElementsData {\n    name: string;\n    type: DataType;\n    return?: DataReturnType;\n}\n\nexport type ElementsDataType = { [key: string]: ElementsData };\n\nexport const WebmElements: ElementsDataType = {\n    '1a45dfa3': { name: 'ebml', type: DataType.master },\n    '4286': { name: 'ebmlVersion', type: DataType.uint, return: DataReturn.uint },\n    '42f7': { name: 'ebmlReadVersion', type: DataType.uint, return: DataReturn.uint },\n    '42f2': { name: 'ebmlMaxIDLength', type: DataType.uint, return: DataReturn.uint },\n    '42f3': { name: 'ebmlMaxSizeLength', type: DataType.uint, return: DataReturn.uint },\n    '4282': { name: 'docType', type: DataType.string, return: DataReturn.string },\n    '4287': { name: 'docTypeVersion', type: DataType.uint, return: DataReturn.uint },\n    '4285': { name: 'docTypeReadVersion', type: DataType.uint, return: DataReturn.uint },\n    '18538067': { name: 'segment', type: DataType.master },\n    '114d9b74': { name: 'seekHead', type: DataType.master },\n    '4dbb': { name: 'seek', type: DataType.master },\n    '53ab': { name: 'seekId', type: DataType.binary },\n    '53ac': { name: 'seekPosition', type: DataType.uint, return: DataReturn.uint },\n    '1549a966': { name: 'info', type: DataType.master },\n    '4489': { name: 'duration', type: DataType.float, return: DataReturn.float },\n    '4d80': { name: 'muxingApp', type: DataType.string, return: DataReturn.string },\n    '5741': { name: 'writingApp', type: DataType.string, return: DataReturn.string },\n    '1f43b675': { name: 'cluster', type: DataType.master },\n    'e7': { name: 'clusterTimecode', type: DataType.uint, return: DataReturn.uint },\n    'a3': { name: 'simpleBlock', type: DataType.binary },\n    '1654ae6b': { name: 'tracks', type: DataType.master },\n    'ae': { name: 'trackEntry', type: DataType.master },\n    'd7': { name: 'trackNumber', type: DataType.uint, return: DataReturn.uint },\n    '83': { name: 'trackType', type: DataType.uint, return: DataReturn.uint },\n    '86': { name: 'codecID', type: DataType.string, return: DataReturn.string },\n    'e1': { name: 'audio', type: DataType.master },\n    'b5': { name: 'samplingFrequency', type: DataType.float, return: DataReturn.float },\n    '9f': { name: 'channels', type: DataType.uint, return: DataReturn.uint },\n    '6264': { name: 'bitDepth', type: DataType.uint, return: DataReturn.uint },\n    '1c53bb6b': { name: 'cues', type: DataType.master },\n    'bb': { name: 'cuePoint', type: DataType.master },\n    'b3': { name: 'cueTime', type: DataType.uint, return: DataReturn.uint },\n    'b7': { name: 'cueTrackPositions', type: DataType.master },\n    'f7': { name: 'cueTrack', type: DataType.uint, return: DataReturn.uint },\n    'f1': { name: 'cueClusterPosition', type: DataType.uint, return: DataReturn.uint }\n};\n","import { EBML, ElementsData, Segment } from './WebmConstant';\n\nexport class WebmHeader {\n    ebml: EBML;\n    segment: Segment;\n    audioTrack: number;\n\n    constructor() {\n        this.ebml = {};\n        this.segment = {};\n        this.audioTrack = -1;\n    }\n\n    parse(ebmlID: ElementsData, chunk: Buffer) {\n        switch (ebmlID.name) {\n            case 'ebml':\n                this.ebml = {};\n                break;\n\n            case 'ebmlVersion':\n                if (ebmlID.return) this.ebml.version = ebmlID.return(chunk) as number;\n                break;\n\n            case 'ebmlReadVersion':\n                if (ebmlID.return) this.ebml.readVersion = ebmlID.return(chunk) as number;\n                break;\n\n            case 'ebmlMaxIDLength':\n                if (ebmlID.return) this.ebml.maxIDLength = ebmlID.return(chunk) as number;\n                break;\n\n            case 'ebmlMaxSizeLength':\n                if (ebmlID.return) this.ebml.maxSizeWidth = ebmlID.return(chunk) as number;\n                break;\n\n            case 'docType':\n                if (ebmlID.return) {\n                    const doctype = ebmlID.return(chunk) as string;\n                    if (doctype !== 'webm') return new Error('This is not a Webm Stream. [ DocType !== webm ]');\n                    else this.ebml.docType = doctype;\n                }\n                break;\n\n            case 'docTypeVersion':\n                if (ebmlID.return) this.ebml.docTypeVersion = ebmlID.return(chunk) as number;\n                break;\n\n            case 'docTypeReadVersion':\n                if (ebmlID.return) this.ebml.docTypeReadVersion = ebmlID.return(chunk) as number;\n                break;\n\n            case 'segment':\n                this.segment = {};\n                break;\n\n            case 'seekHead':\n                this.segment.seekHead = [];\n                break;\n\n            case 'seekPosition':\n                if (ebmlID.return) this.segment.seekHead!.push({ position: ebmlID.return(chunk) as number });\n                break;\n\n            case 'info':\n                this.segment.info = {};\n                break;\n\n            case 'duration':\n                if (ebmlID.return) this.segment.info!.duration = ebmlID.return(chunk) as number;\n                break;\n\n            case 'muxingApp':\n                if (ebmlID.return) this.segment.info!.muxingApp = ebmlID.return(chunk) as string;\n                break;\n\n            case 'writingApp':\n                if (ebmlID.return) this.segment.info!.writingApp = ebmlID.return(chunk) as string;\n                break;\n\n            case 'cluster':\n                this.segment.cluster = {};\n                break;\n\n            case 'clusterTimecode':\n                if (ebmlID.return) this.segment.cluster!.time = ebmlID.return(chunk) as number;\n                break;\n\n            case 'simpleBlock':\n                break;\n\n            case 'tracks':\n                this.segment.tracks = [];\n                break;\n\n            case 'trackEntry':\n                this.segment.tracks!.push({});\n                break;\n\n            case 'trackNumber':\n                if (ebmlID.return)\n                    this.segment.tracks![this.segment.tracks!.length - 1].trackNumber = ebmlID.return(chunk) as number;\n                break;\n\n            case 'trackType':\n                if (ebmlID.return) {\n                    const type = ebmlID.return(chunk) as number;\n                    if (type === 2) this.audioTrack = this.segment.tracks!.length - 1;\n                    this.segment.tracks![this.segment.tracks!.length - 1].trackType = type;\n                }\n                break;\n\n            case 'codecID':\n                if (ebmlID.return) {\n                    const codec = ebmlID.return(chunk) as string;\n                    if (codec !== 'A_OPUS' && this.segment.tracks![this.segment.tracks!.length - 1].trackType === 2)\n                        return new Error('Audio Codec is not OPUS');\n                    this.segment.tracks![this.segment.tracks!.length - 1].codecID = codec;\n                }\n                break;\n\n            case 'audio':\n                this.segment.tracks![this.segment.tracks!.length - 1].audio = {};\n                break;\n\n            case 'samplingFrequency':\n                if (ebmlID.return)\n                    this.segment.tracks![this.segment.tracks!.length - 1].audio!.rate = ebmlID.return(chunk) as number;\n                break;\n\n            case 'channels':\n                if (ebmlID.return)\n                    this.segment.tracks![this.segment.tracks!.length - 1].audio!.channels = ebmlID.return(\n                        chunk\n                    ) as number;\n                break;\n\n            case 'bitDepth':\n                if (ebmlID.return)\n                    this.segment.tracks![this.segment.tracks!.length - 1].audio!.bitDepth = ebmlID.return(\n                        chunk\n                    ) as number;\n                break;\n\n            case 'cues':\n                this.segment.cues = [];\n                break;\n\n            case 'cuePoint':\n                this.segment.cues!.push({});\n                break;\n\n            case 'cueTime':\n                if (ebmlID.return)\n                    this.segment.cues![this.segment.cues!.length - 1].time = ebmlID.return(chunk) as number;\n                break;\n\n            case 'cueTrack':\n                if (ebmlID.return)\n                    this.segment.cues![this.segment.cues!.length - 1].track = ebmlID.return(chunk) as number;\n                break;\n\n            case 'cueClusterPosition':\n                if (ebmlID.return)\n                    this.segment.cues![this.segment.cues!.length - 1].position = ebmlID.return(chunk) as number;\n                break;\n\n            default:\n                break;\n        }\n    }\n}\n","import { IncomingMessage } from 'node:http';\nimport { RequestOptions, request as httpsRequest } from 'node:https';\nimport { URL } from 'node:url';\nimport { createGunzip } from 'node:zlib';\nimport os from 'node:os';\nimport fs from 'fs';\nimport { resolve } from 'node:path';\nimport { spawn } from 'node:child_process';\nimport { Readable } from 'node:stream';\nimport process from 'node:process';\n\n\nlet FFMPEG_COMMAND: string | undefined = undefined\n\ninterface FFmpegDownloadOptions {\n    path?: string;\n    debug?: boolean;\n    force?: boolean;\n}\n\ninterface FFmpegOptions {\n    input?: string | Readable;\n    args?: string[];\n}\n\nexport async function ffmpeg(options: FFmpegOptions = {}) {\n    const platform = os.platform()\n    let args = options.args || [];\n    args.unshift('-i', typeof options.input === 'string' ? options.input : '-');\n    \n    if (!FFMPEG_COMMAND)\n    throw new Error(\n        'You forgot to initialize FFMPEG. Try using await initializeFFmpeg() before using this function.'\n        );\n    let command = FFMPEG_COMMAND\n    if (FFMPEG_COMMAND === 'npx') args.unshift(`ffmpeg${platform === \"win32\" ? \".exe\" : ''}`);\n\n    args.push('pipe:1');\n    const ffmpegprocess = spawn(command, args, { shell: true, windowsHide: true });\n    if (options.input instanceof Readable) options.input.pipe(ffmpegprocess.stdin)\n    return ffmpegprocess.stdout;\n}\n\nexport async function ffmpeg_download(options: FFmpegDownloadOptions = {}) {\n    if (!options.path) options.path = './node_modules/.bin/';\n    if (fs.existsSync(options.path)) fs.mkdirSync(options.path, { recursive: true });\n\n    const arch = os.arch();\n    const platform = os.platform();\n\n    const real_path = resolve(options.path, `ffmpeg${platform === \"win32\" ? \".exe\" : ''}`);\n    if (fs.existsSync(real_path) && !options.force) {\n        process.stdout.write(`You already have ffmpeg installed at ${real_path}\\n`);\n        return;\n    }\n    let response = await https_getter('https://github.com/play-dl/play-audio/releases/latest');\n    const release_id = response.headers.location?.split('tag/')[1];\n\n    response = await https_getter(\n        `https://github.com/play-dl/play-audio/releases/download/${release_id}/ffmpeg-${platform}-${arch}.${\n            platform === 'win32' ? 'exe.gz' : 'gz'\n        }`\n    );\n    if (response.statusCode! > 400) {\n        process.stdout.write(\n            `We don't currently support your platform and architecture. \\nIf you want support for ffmpeg static build, create a issue at play-audio repository with following logs.\\nPlatform : ${platform}\\nArch : ${arch}\\n`\n        );\n        return;\n    } else if (response.statusCode! > 300) response = await https_getter(response.headers.location!);\n    const write = fs.createWriteStream(real_path);\n    response.pipe(createGunzip()).pipe(write);\n    if (options.debug === true) {\n        const length: number = parseInt(response.headers['content-length']!) - 1;\n        let bytes: number = 0;\n        response.on('data', (x: Buffer) => {\n            bytes += x.length;\n            process.stdout.clearLine(0);\n            process.stdout.cursorTo(0);\n            process.stdout.write(`FFmpeg Download status : ${((bytes / length) * 100).toFixed(0)} %`);\n        });\n    }\n    write.once('finish', () => {\n        fs.chmodSync(real_path, '755');\n        process.stdout.write('\\n');\n    });\n}\n\ninterface RequestOpts extends RequestOptions {\n    body?: string;\n    method?: 'GET' | 'POST' | 'HEAD';\n    cookies?: boolean;\n    cookieJar?: { [key: string]: string };\n}\n\nfunction https_getter(req_url: string, options: RequestOpts = {}): Promise<IncomingMessage> {\n    return new Promise((resolve, reject) => {\n        const s = new URL(req_url);\n        options.method ??= 'GET';\n        const req_options: RequestOptions = {\n            host: s.hostname,\n            path: s.pathname + s.search,\n            headers: options.headers ?? {},\n            method: options.method\n        };\n\n        const req = httpsRequest(req_options, resolve);\n        req.on('error', (err) => {\n            reject(err);\n        });\n        if (options.method === 'POST') req.write(options.body);\n        req.end();\n    });\n}\n\n\nexport async function initializeFFmpeg(preference?: \"npx\" | \"global\" | \"local\"): Promise<boolean> {\n    const platform = os.platform();\n    let command = `ffmpeg${platform === \"win32\" ? \".exe\" : ''}`, args: string[] = []\n    switch(preference){\n        case \"npx\":\n            args = [command]\n            command = 'npx'\n            break\n\n        case \"local\":\n            const paths = [resolve(`./node_modules/.bin/${command}`), resolve(`../node_modules/.bin/${command}`)]\n            if(fs.existsSync(paths[0])) command = paths[0]\n            else if(fs.existsSync(paths[1])) command = paths[1]\n            else return false\n            break\n\n        case undefined:\n            const result = await initializeFFmpeg(\"local\")\n            if(result === false) return initializeFFmpeg(\"global\")\n            else return true \n    }\n    args.push('-h')\n    const ffmpegprocess = spawn(command, args, { shell : true, windowsHide: true })\n    return new Promise((res) => {\n        ffmpegprocess.once('close', (code) => {\n            if(code === 0) {\n                FFMPEG_COMMAND = command\n                res(true)\n            }\n            else res(false)\n        })\n    })\n}","import { OpusDecoder, OpusEncoder } from './opus';\n\nimport { OggDemuxer } from './ogg';\n\nimport { WebmDemuxer, WebmHeader, WebmElements } from './webm';\n\nimport { ffmpeg_download, ffmpeg, initializeFFmpeg } from './ffmpeg';\n\nexport { OpusDecoder, OggDemuxer, OpusEncoder, WebmDemuxer, WebmHeader, WebmElements, ffmpeg_download, ffmpeg, initializeFFmpeg };\n\nexport default {\n    OpusDecoder,\n    OggDemuxer,\n    OpusEncoder,\n    WebmDemuxer,\n    WebmHeader,\n    WebmElements,\n    ffmpeg_download,\n    ffmpeg,\n    initializeFFmpeg\n};\n"],"mappings":"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","names":[]}